import os
import time
import shutil
import subprocess
from logger import logger
from radon.complexity import cc_visit
from utils.utils import update_metrics, write_py

os.environ["PYTHONIOENCODING"] = "utf-8"


class EvaluateAICode:
    """
    Evaluated the AI code generated by CodeLlama.
    """

    def __init__(self):
        self.reward = 0
        self.error = None

    def compute_complexity(self, code: str):
        """
        Computes cyclomatic complexity and returns a high value if analysis fails.
        """
        try:
            return sum(func.complexity for func in cc_visit(code=code))

        except Exception as e:
            return float("inf")

    def analyze_AI_code(self, filename: str, original_code: str, ai_code: str):
        """
        Analyzes AI code for complexity and maintainability.
        """
        logger.info(f"{filename}: Analyzing Cyclomatic Complexity and Maintainability Index...")

        # Compute complexity
        original_cc = self.compute_complexity(original_code)
        ai_cc = self.compute_complexity(ai_code)

        # Compute maintainability index
        original_mi = original_code.count("\n")
        ai_mi = ai_code.count("\n")

        logger.info(
            f"{filename}: Cyclomatic Complexity: Original code: {original_cc}, AI code: {ai_cc}"
        )
        logger.info(
            f"{filename}: Maintainability Index: Original code: {original_mi}, AI code: {ai_mi}"
        )

        update_metrics(
            filename=filename,
            key="Cyclomatic Complexity",
            value=f"Original code: {original_cc}, AI code: {ai_cc}",
        )

        update_metrics(
            filename=filename,
            key="Maintainability Index",
            value=f"Original code: {original_mi}, AI code: {ai_mi}",
        )

        # Reward for reduced complexity
        if ai_cc < original_cc:
            self.reward += 5

        # Reward for improved maintainability
        if ai_mi > original_mi:
            self.reward += 5

        return self.reward

    def execute_code(self, filename: str, ai_code: str):
        """
        Executes AI-generated code in a new terminal window and captures errors properly.
        """
        backup_filename = f"{filename}.backup"

        try:
            # Backup the original file before modifying
            shutil.copy(filename, backup_filename)

            # Write AI-generated code to the file
            write_py(filename, ai_code)

            # Open a new command prompt, execute the AI code, and capture errors
            process = subprocess.Popen(
                ["cmd.exe", "/c", f"call conda activate sic && python {filename}"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                encoding="utf-8",
                text=True,
                shell=True,  # Required for conda activation to work properly
            )

            # Capture output and errors
            stdout, stderr = process.communicate()

            if process.returncode == 0:
                self.reward += 10
                return True
            else:
                self.error = stderr
                logger.error(f"{filename}: Execution failed! {stderr}")
                return False

        except Exception as e:
            self.error = str(e)
            logger.exception(f"{filename}: Execution failed! {self.error}")
            return False

        finally:
            # Restore the original file to prevent corruption
            shutil.move(backup_filename, filename)

    def execute_DVC_pipeline(self, filename: str, ai_code: str):
        """
        Executes DVC pipeline in a new terminal window and closes it after execution.
        """
        backup_filename = f"{filename}.backup"
        logger.info(f"{filename}: Executing DVC pipeline...")

        try:
            # Backup the original file before modifying
            shutil.copy(filename, backup_filename)

            # Write AI-generated code to the file
            write_py(filename, ai_code)

            # Open a new command prompt, execute the DVC pipeline, and capture errors
            process = subprocess.Popen(
                ["cmd.exe", "/c", f"call conda activate sic && dvc repro --force"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                encoding="utf-8",
                text=True,
                shell=True,  # Required for conda activation to work properly
            )

            # Capture output and errors
            stdout, stderr = process.communicate()

            if process.returncode == 0:
                self.reward += 10
                return True
            else:
                self.error = stderr
                logger.error(f"{filename}: DVC pipeline failed! {stderr}")
                return False

        except Exception as e:
            self.error = str(e)
            logger.exception(f"{filename}: DVC pipeline failed! {self.error}")
            return False

        finally:
            # Restore the original file to prevent corruption
            shutil.move(backup_filename, filename)

    def evaluate(self, filename: str, original_code: str, ai_code: str):
        """
        Evaluates AI code for correctness, complexity and execution.
        """
        logger.info(f"{filename}: Starting evaluation process...")

        try:
            # Analyze AI code and update reward
            self.reward += self.analyze_AI_code(filename, original_code, ai_code)

            # Measure execution time for Original code
            start_time_original = time.perf_counter()
            logger.info(f"{filename}: Executing Original code...")

            success_original = self.execute_code(filename, original_code)
            end_time_original = time.perf_counter()

            # If Original execution fails, return immediately
            if not success_original:
                return False, self.reward, self.error

            # Measure execution time for AI-generated code
            start_time_ai = time.perf_counter()
            logger.info(f"{filename}: Executing AI code...")

            success_ai = self.execute_code(filename, ai_code)
            end_time_ai = time.perf_counter()

            # If AI execution fails, return immediately
            if not success_ai:
                return False, self.reward, self.error

            # Calculate execution times
            original_execution_time = end_time_original - start_time_original
            ai_execution_time = end_time_ai - start_time_ai

            # Calculate speed improvement percentage
            if original_execution_time > 0:
                speed_increase = (
                    (original_execution_time - ai_execution_time)
                    / original_execution_time
                ) * 100
            else:
                speed_increase = 0  # Avoid division by zero

            # Log execution details
            logger.info(
                f"{filename}: Original code execution time: {original_execution_time:.6f} seconds"
            )
            logger.info(
                f"{filename}: AI code execution time: {ai_execution_time:.6f} seconds"
            )
            logger.info(
                f"{filename}: Execution speed improvement: {speed_increase:.2f}%"
            )

            update_metrics(
                filename=filename,
                key="Original code execution time",
                value=f"{original_execution_time:.6f}seconds",
            )
            update_metrics(
                filename=filename,
                key="AI code execution time",
                value=f"{ai_execution_time:.6f}seconds",
            )
            update_metrics(
                filename=filename,
                key="Execution speed improvement",
                value=f"{speed_increase:.2f}%",
            )

            # Execute DVC pipeline
            if not self.execute_DVC_pipeline(filename, ai_code):
                return False, self.reward, self.error

            return True, self.reward, None

        except Exception as e:
            self.reward -= 10
            self.error = str(e)
            logger.exception(f"{filename}: Evaluation failed! {self.error}")
            return False, self.reward, self.error
